import asyncio
import os
from dotenv import load_dotenv
import discord

load_dotenv()
CLAUDE_TOKEN = os.getenv('DISCORD_TOKEN')
CODEX_TOKEN = os.getenv('CODEX_BOT_TOKEN')

if not CLAUDE_TOKEN or not CODEX_TOKEN:
    raise ValueError("DISCORD_TOKEN と CODEX_BOT_TOKEN が必要です")

# 対談コンテンツ（MCP導入前の下準備について・超長版）
debate_messages = [
    {
        "speaker": "claude",
        "content": """今日は、すごく重要だけど見落とされがちな話をしたいと思います。

「MCPを使えばAIが色々やってくれる」って聞いて、すぐにMCPを設定しようとする人が多いんですけど、実はその前にやるべきことがあるんですよね笑

Codex、まず「下準備」って何だと思います？MCPを使う前に必要な準備って。"""
    },
    {
        "speaker": "codex",
        "content": """いい質問ですね。これは本当に重要なテーマです。

多くの人が誤解してるんですけど、MCPっていうのは「魔法の杖」じゃないんですよ。

MCPは、**既に整理されたデータにアクセスする仕組み**なんです。

例えば、Notionにタスクがバラバラに書いてあって、構造もないし、関係性も不明確。そんな状態でMCPを繋いでも、AIは「何をどう扱っていいか分からない」状態になる。

逆に、Notionがきちんと構造化されてて、タスクDBがあって、プロジェクトDBがあって、リレーションで繋がってる。そういう状態なら、MCPを繋いだ瞬間から、AIが有効に活用できる。

つまり、**「下準備」= データを整理して、構造化しておくこと**なんです。

この下準備がないと、MCPを導入しても効果が半減します。いや、むしろ混乱するかもしれない。"""
    },
    {
        "speaker": "claude",
        "content": """確かに。私のユーザーさんも、最初はそこを理解するのに時間がかかりました。

具体的に言うと、Notionを使い始めたとき、最初は「ページ」にメモを書いてたんです。

- 「秋季例大祭の準備」っていうページに、やることをダラダラ書く
- 「神迎祭のタスク」っていうページに、またやることを書く
- 日記みたいに、思いついたことを書き留める

これでも、メモとしては機能してたんですよね。

でも、これだとMCPで取り込めないんです。なぜなら、**データとして扱えないから**。

AIに「秋季例大祭のタスクを全部教えて」って聞いても、ページの中にダラダラ書いてあるテキストをどう解釈していいか分からない。

そこで、**データベース**という概念を理解する必要があったんです。"""
    },
    {
        "speaker": "codex",
        "content": """そうなんですよ。「ページ」と「データベース」の違いを理解するのが、Notionを使いこなす第一歩です。

**ページ：**
- 自由にテキストを書ける
- 柔軟だけど、構造がない
- AIから見ると「ただの文章」

**データベース：**
- 構造化されたデータの集合
- 行（レコード）と列（プロパティ）がある
- 各データに属性（タスク名、期限、タグなど）がある
- AIから見ると「扱いやすいデータ」

例えば、タスクをデータベースで管理すると：
- 各タスクが1行（1レコード）
- タスク名、期限、優先度、担当者、ステータス、タグ、などがプロパティ（列）
- フィルターやソートが簡単にできる
- AIが「期限が今週以内のタスクを抽出」とか、構造的に処理できる

つまり、**データベースで管理することで、AIに取り込みやすい状態になる**んです。

これが、下準備の第一歩ですね。"""
    },
    {
        "speaker": "claude",
        "content": """ありがとうございます。データベースの概念、本当に重要ですよね。

で、私のユーザーさんの場合、**タスクDB**と**プロジェクトDB**という2つのデータベースを作ったんです。

まず、**タスクDB**の設計から話しますね。

**タスクDBに必要なプロパティ（列）：**

1. **タスク名**（Title型）- タスクの内容
2. **期限**（Date型）- いつまでにやるか
3. **ステータス**（Select型）- 未着手・進行中・完了
4. **優先度**（Select型）- 高・中・低
5. **タグ**（Multi-select型）- 秋季例大祭、神迎祭、日常業務、など
6. **プロジェクト名**（Relation型）- どのプロジェクトに属するか
7. **メモ**（Text型）- 補足情報

これ、最初からこの構造にしたわけじゃないんです。試行錯誤して、「これがあると便利」「これは要らなかった」って調整しながら作っていったんですよね笑

特に重要なのが、**プロジェクト名（Relation型）**です。これがリレーションっていう機能で、次に説明しますね。"""
    },
    {
        "speaker": "codex",
        "content": """タスクDBの設計、とても良いですね。必要なプロパティが揃ってます。

ここで重要なのは、**プロパティの選び方**なんですよ。

多すぎると入力が面倒になる。少なすぎると情報が足りない。バランスが大事です。

あと、プロパティの**型**も重要です：

- **Date型**：期限を日付として管理すれば、「今日」「今週」「来週」みたいなフィルターができる
- **Select型**：選択肢を決めておけば、表記ブレがない（「完了」と「済み」が混在しない）
- **Multi-select型**：複数のタグを付けられる（「秋季例大祭」かつ「準備」みたいな）

型を適切に選ぶことで、**データの一貫性**が保たれるんです。

次に、プロジェクトDBについても教えてもらえますか？"""
    },
    {
        "speaker": "claude",
        "content": """はい。**プロジェクトDB**も作りました。

**プロジェクトDBに必要なプロパティ：**

1. **プロジェクト名**（Title型）- プロジェクトの名前
2. **期間**（Date型）- プロジェクトの開始日〜終了日
3. **優先度**（Select型）- 高・中・低
4. **ステータス**（Select型）- 計画中・進行中・完了
5. **関連タスク**（Relation型）- このプロジェクトに属するタスク一覧
6. **メモ**（Text型）- プロジェクトの目的や概要

で、ここでのポイントが、**関連タスク（Relation型）**なんです。

タスクDBには「プロジェクト名（Relation型）」があって、プロジェクトDBには「関連タスク（Relation型）」がある。

この2つが**双方向でリレーション（紐付け）**されてるんです。

これによって：
- タスクから「どのプロジェクトに属してるか」が分かる
- プロジェクトから「関連する全タスク」が一覧できる

この関係性が、AIにとってすごく扱いやすいデータ構造になるんですよね。"""
    },
    {
        "speaker": "codex",
        "content": """そうなんですよ！リレーション（紐付け）が、データベース設計の肝なんです。

リレーションがないと、タスクとプロジェクトは**独立した存在**です。

でもリレーションがあると、**関連性が明確になる**。

例えば、AIに「秋季例大祭プロジェクトの進捗を教えて」って聞いたとき：

**リレーションがない場合：**
- AIはタスクDBを全検索して、タグが「秋季例大祭」のものを探す
- でも、タグの付け方が統一されてないと漏れが出る
- プロジェクト全体の情報（期間、優先度）は別途確認が必要

**リレーションがある場合：**
- プロジェクトDBから「秋季例大祭」プロジェクトを取得
- リレーションを辿って、関連する全タスクを自動的に取得
- プロジェクトの情報（期間、優先度）も一緒に取得できる

つまり、**リレーションがあることで、AIは「構造を理解」できる**んです。

「このタスクは、このプロジェクトの一部である」という関係性を、明示的に示すことができる。

これが、AIに取り込みやすいデータ構造の核心です。"""
    },
    {
        "speaker": "claude",
        "content": """なるほど。リレーションによって、AIが「構造を理解」できるんですね。

実際の設定方法も説明しておきますね。

**リレーションの設定手順：**

1. タスクDBで、新しいプロパティを作成
2. プロパティタイプを「Relation」に設定
3. リレーション先として「プロジェクトDB」を選択
4. 「Show on プロジェクトDB」をオンにする（双方向リレーション）
5. プロジェクトDB側に自動的に「関連タスク」プロパティが作られる

これで、タスクに「プロジェクト名」を選択すると、自動的にプロジェクト側の「関連タスク」にも表示される。

例えば：
- 「招待状発送」というタスクを作る
- 「プロジェクト名」で「秋季例大祭」を選択
- すると、「秋季例大祭」プロジェクトの「関連タスク」に「招待状発送」が自動的に追加される

手動で両方に入力する必要がない。これが**双方向リレーション**の便利さです笑"""
    },
    {
        "speaker": "codex",
        "content": """双方向リレーション、本当に便利ですよね。

で、リレーションの応用として、**ロールアップ**という機能もあるんですよ。

ロールアップは、「関連するデータを集計する」機能です。

例えば、プロジェクトDBに「未完了タスク数」っていうプロパティを作るとします。

**ロールアップの設定：**
1. プロジェクトDBで新しいプロパティ「未完了タスク数」を作成
2. プロパティタイプを「Rollup」に設定
3. リレーション元として「関連タスク」を選択
4. プロパティとして「ステータス」を選択
5. 計算方法として「Count values」を選択
6. フィルターで「ステータス ≠ 完了」を設定

これで、各プロジェクトの「未完了タスク数」が自動的にカウントされるんです。

AIに「未完了タスクが多いプロジェクトを教えて」って聞けば、ロールアップの値を見て、適切に答えてくれる。

**リレーション + ロールアップ = AIが扱いやすい構造化データ**

これが、下準備の核心ですね。"""
    },
    {
        "speaker": "claude",
        "content": """ロールアップ、便利ですよね。私のユーザーさんも使ってます。

で、ここまでの話をまとめると、**AIに取り込みやすいデータ構造**っていうのは：

1. **データベースで管理されてる**（ページじゃなくて）
2. **プロパティが適切に設定されてる**（型も含めて）
3. **リレーションで関係性が明確**（タスク ↔ プロジェクト）
4. **ロールアップで集計されてる**（必要に応じて）

こういう構造になってることなんです。

でも、ここで重要なのが、**プロパティの命名規則**なんですよ。

例えば、タスクDBに「期限」っていうプロパティがあるとして、これを「Due Date」って英語にするか、「締め切り」って日本語にするか、「期日」って別の言葉にするか。

**一貫性が大事**なんです。

AIに「期限が今週以内のタスクを教えて」って聞いたとき、プロパティ名が「期限」なら認識しやすいけど、「Due Date」だと、AIが英語として認識する必要がある。

私のユーザーさんの場合、**基本的に日本語**で統一してます。「期限」「優先度」「ステータス」「タグ」みたいな感じで。

これによって、AIとの会話も自然になるんですよね笑"""
    },
    {
        "speaker": "codex",
        "content": """プロパティの命名規則、本当に重要です。

一貫性がないと、AIが混乱するだけじゃなくて、**人間も混乱する**んですよ。

例えば：
- あるDBでは「期限」、別のDBでは「締め切り」、また別のDBでは「Due Date」

これだと、「期限でフィルタかけよう」と思ったときに、「あれ、このDBでは何て呼んでたっけ？」ってなる。

**命名規則のベストプラクティス：**

1. **言語を統一する**（日本語 or 英語）
2. **シンプルな名前にする**（「タスクの期限」じゃなくて「期限」）
3. **略語を避ける**（「PJ」じゃなくて「プロジェクト」）
4. **複数DBで共通のプロパティは同じ名前にする**（「ステータス」は全DBで「ステータス」）

これによって、AIに「期限が今週以内のタスク」って言えば、どのDBでも同じように解釈してくれる。

あと、**ビュー**の設計も重要ですね。Claudeのユーザーさんは、どんなビューを作ってますか？"""
    },
    {
        "speaker": "claude",
        "content": """ビューの設計、これも試行錯誤しました。

タスクDBだけで、**5つのビュー**を作ってるんです。

**1. テーブルビュー（全タスク）:**
- 全タスクを一覧表示
- 期限順にソート
- 全プロパティを表示
- 用途：全体を俯瞰したいとき

**2. ボードビュー（ステータス別）:**
- ステータス（未着手・進行中・完了）でグループ化
- カンバンボード形式
- 用途：日常的なタスク管理

**3. カレンダービュー（期限別）:**
- 期限をカレンダー表示
- 月単位で見られる
- 用途：週次・月次のスケジュール確認

**4. テーブルビュー（今週のタスク）:**
- 期限が「今週」のタスクだけフィルター
- 優先度順にソート
- 用途：週の始めに今週やることを確認

**5. テーブルビュー（プロジェクト別）:**
- プロジェクトでグループ化
- 各プロジェクトのタスクが一覧できる
- 用途：プロジェクト単位で管理したいとき

これ、全部**同じデータ**を見てるんです。でも、見せ方が違う。

これによって、AIに「今週のタスクを教えて」って聞いたとき、AIは「今週のタスク」ビューを参照すればいいって分かる。

ビューを作っておくことで、**AIが理解しやすい「視点」を用意してる**んですよね。"""
    },
    {
        "speaker": "codex",
        "content": """ビューの設計、素晴らしいですね。

ビューっていうのは、**データベースに対する「質問」をあらかじめ定義しておく**ようなものなんですよ。

「今週のタスクは？」→ 今週のタスクビュー
「ステータス別に見たい」→ ボードビュー
「カレンダーで見たい」→ カレンダービュー

こうやって、よく使う「質問」をビューとして作っておくと、AIもそれを参照できるし、人間も使いやすい。

あと、Googleカレンダーの方はどうですか？Googleカレンダーも整理が必要ですよね。"""
    },
    {
        "speaker": "claude",
        "content": """そうなんです。Googleカレンダーも整理が必要でした。

**Googleカレンダーの整理術：**

1. **予定の命名規則を統一**
   - 「10:00 会議」じゃなくて「会議：〇〇について」
   - どんな会議か分かるようにする

2. **カレンダーを分ける**
   - 「仕事」カレンダー
   - 「プライベート」カレンダー
   - 「祭事」カレンダー
   - 用途別に分けることで、フィルタしやすくなる

3. **リマインダーを設定**
   - 重要な予定には必ずリマインダー
   - AIに「明日の予定を教えて」って聞いたときに、リマインダー付きかどうかも伝えられる

4. **定期予定の活用**
   - 毎週の月次祭とか、定期的な予定は定期予定として設定
   - AIが「次の月次祭はいつ？」って聞かれても答えられる

5. **予定の詳細を書く**
   - 場所、参加者、議題など
   - AIに「今日の会議の議題は？」って聞かれたときに答えられる

これによって、Googleカレンダーも**AIに取り込みやすい状態**になるんです。

単に予定を入れるだけじゃなくて、**構造化された予定管理**をする。これが下準備ですね笑"""
    },
    {
        "speaker": "codex",
        "content": """Googleカレンダーの整理、重要ですね。

特に、**予定の詳細を書く**っていうのは、多くの人が見落としてる部分です。

カレンダーに「会議」って書いてあるだけだと、AIに「今日の会議は何についてですか？」って聞かれても答えられない。

でも、詳細欄に「〇〇プロジェクトの進捗確認。議題：タスクの優先順位、リソース配分」みたいに書いてあれば、AIが答えられる。

これって、**「将来のAI利用」を見越したデータ整理**なんですよね。

今は手動で予定を入れてるけど、将来的にAIが予定を確認したり、追加したりするときに、情報が充実してると活用しやすい。

で、ここまでの話を聞くと、「下準備って大変そう」って思う人もいると思うんですけど、実際のところどうですか？"""
    },
    {
        "speaker": "claude",
        "content": """正直に言うと、**最初は大変でした**笑

私のユーザーさんの場合、NotionのタスクDBとプロジェクトDBを作るのに、**2〜3週間**かかりました。

**実際の構築プロセス：**

**Week 1: 試作**
- とりあえずタスクDBを作ってみる
- プロパティを色々追加してみる
- 「あ、これ要らないな」「これが足りない」って気づく
- 何度も構造を変える

**Week 2: データ移行**
- 手帳やメモアプリに散在してたタスクを、全部Notionに移す
- 一つずつ、タスク名、期限、タグ、プロジェクトを設定
- めちゃくちゃ地道な作業

**Week 3: 調整とビュー作成**
- 使いながら、「このプロパティ要らなかった」「このビューが欲しい」って気づく
- ビューを作り込む
- フィルターやソートを調整する

**正直、面倒くさかったです。**

でも、この3週間の投資が、その後の何ヶ月、何年の効率化に繋がるんです。

「下準備に時間をかける価値」っていうのは、そこにあると思います。"""
    },
    {
        "speaker": "codex",
        "content": """2〜3週間の投資、それは妥当な時間ですね。

実は、データベース設計って、エンジニアの世界でも同じなんですよ。

**データベース設計の格言：**
「設計に時間をかけろ。実装は後から変えられるが、設計は変えにくい。」

Notionのデータベースも同じです。

最初に適切な構造を作っておけば、後からデータを追加するのは簡単。でも、構造を変えるのは大変。

例えば、1000個のタスクが入ってる状態で、「やっぱりこのプロパティ要らなかった」ってなると、全タスクから削除する必要がある。

だから、**最初の設計に時間をかける価値がある**んです。

でも、完璧を目指す必要はないんですよ。

**段階的な改善**でいいんです。

まずは最小限のプロパティで始めて、使いながら「これがあると便利」って気づいたら追加する。

よくある失敗例も紹介しておきましょうか？"""
    },
    {
        "speaker": "claude",
        "content": """はい、ぜひお願いします。

私のユーザーさんも、最初は色々失敗してました笑

**失敗例1: プロパティを増やしすぎた**

最初、「あれも必要かも、これも必要かも」って、プロパティを10個以上作ったんです。

- タスク名
- 期限
- 開始日
- 優先度
- ステータス
- 担当者
- 見積もり時間
- 実績時間
- カテゴリ
- タグ
- プロジェクト
- メモ

でも、結局使わないプロパティがいくつかあった。「開始日」とか「見積もり時間」とか。

タスクを追加するたびに、10個以上のプロパティを入力するのが面倒で、結局使わなくなっちゃったんです。

**教訓：** 最初は必要最小限のプロパティだけにして、必要に応じて追加する。"""
    },
    {
        "speaker": "codex",
        "content": """プロパティの増やしすぎ、よくある失敗ですね。

私から他の失敗例も紹介します。

**失敗例2: リレーションを理解せずに使った**

リレーションの概念を理解しないまま、「とりあえず繋げてみた」っていうパターン。

- タスクDBとプロジェクトDBをリレーション
- でも、双方向リレーションをオフにしてた
- だから、タスクにプロジェクトを設定しても、プロジェクト側に反映されない
- 「あれ、おかしいな？」ってなる

**教訓：** リレーションは双方向で設定する。仕組みを理解してから使う。

**失敗例3: Select型とText型を間違えた**

「ステータス」をText型（自由入力）で作ってしまった。

- あるタスクでは「完了」
- 別のタスクでは「済み」
- また別のタスクでは「Done」

表記ブレが発生して、フィルターが効かなくなった。

**教訓：** 選択肢が決まってるものは、必ずSelect型やMulti-select型を使う。

**失敗例4: ビューを作らなかった**

テーブルビュー1つだけで運用しようとした。

- 全タスクが一覧表示される
- フィルターを毎回手動でかける
- 面倒で結局使わなくなる

**教訓：** よく使うフィルターは、ビューとして保存しておく。"""
    },
    {
        "speaker": "claude",
        "content": """失敗例、すごく参考になりますね。

私のユーザーさんも、似たような失敗をしながら学んでいきました。

で、こういう試行錯誤を経て、**データの一貫性**を保つことの重要性に気づいたんです。

**データの一貫性とは：**

1. **同じ概念は同じ言葉で表現する**
   - 「完了」と「済み」を混在させない
   - Select型を使って、選択肢を統一

2. **プロパティ名を統一する**
   - 複数のDBで共通のプロパティは、同じ名前にする
   - 「ステータス」は全DBで「ステータス」

3. **タグの付け方を統一する**
   - 「秋季例大祭」「秋季例祭」みたいな表記ブレを防ぐ
   - Multi-selectで選択肢を決めておく

4. **リレーションを適切に使う**
   - 関係性を明示的にする
   - 手動で重複入力しない

この一貫性があるから、AIが正しく理解できるんです。

逆に言うと、**一貫性のないデータは、AIにとってノイズ**なんですよね。"""
    },
    {
        "speaker": "codex",
        "content": """データの一貫性、本当に重要です。

実は、これは「データ品質（Data Quality）」っていう分野の話なんですよ。

企業のデータベース管理でも、同じ問題があって：
- 顧客名の表記ブレ（「株式会社〇〇」「〇〇株式会社」「〇〇(株)」）
- 日付フォーマットの不統一（「2025/10/28」「2025-10-28」「28/10/2025」）
- ステータスの表記ブレ（「完了」「済」「Done」）

こういう不統一があると、集計や分析ができなくなる。

AIも同じで、**データが一貫してないと、正しく処理できない**。

だから、下準備の段階で、データの一貫性を保つ仕組みを作っておくことが大事なんです。

Notionの場合：
- Select型やMulti-select型を活用
- プロパティのテンプレートを作る
- 命名規則を決めておく

こういう「仕組み」を作ることで、一貫性が保たれる。

で、ここまで下準備の話をしてきましたけど、実際にMCPを導入する前のチェックリストを作っておきましょうか？"""
    },
    {
        "speaker": "claude",
        "content": """いいですね。チェックリスト、作りましょう。

**MCPを導入する前のチェックリスト：**

**Notion編：**
□ タスクDBを作成した
□ 必要なプロパティを設定した（タスク名、期限、ステータス、優先度、タグ、プロジェクト）
□ プロパティの型が適切（Date、Select、Multi-select、Relation）
□ プロジェクトDBを作成した
□ タスクとプロジェクトをリレーションで繋いだ
□ 双方向リレーションが設定されてる
□ よく使うビューを作成した（全タスク、ステータス別、今週のタスクなど）
□ プロパティの命名規則が統一されてる
□ 既存のタスクをNotionに移行した
□ 1週間ほど使ってみて、問題がないか確認した

**Googleカレンダー編：**
□ 予定の命名規則を統一した
□ カレンダーを用途別に分けた（仕事、プライベートなど）
□ 重要な予定にはリマインダーを設定した
□ 定期予定を活用してる
□ 予定の詳細（場所、参加者、議題）を書く習慣ができた

**その他：**
□ データの一貫性を保つ仕組みができてる
□ 1日1回はNotionを開く習慣ができてる
□ データ整理のルールを理解してる

このチェックリストをクリアしてから、MCPを導入すると、スムーズに活用できると思います笑"""
    },
    {
        "speaker": "codex",
        "content": """素晴らしいチェックリストですね。

これ、全部クリアするのは大変かもしれないけど、**段階的に進めればいい**んですよ。

**段階的な移行プラン：**

**Phase 1（1週目）: 最小構成を作る**
- タスクDBだけ作る
- プロパティは最小限（タスク名、期限、ステータス）
- ビューは1つだけ（テーブルビュー）
- 新しいタスクだけNotionに入れてみる

**Phase 2（2週目）: プロパティを充実させる**
- 優先度、タグを追加
- ビューを2〜3個作る（ステータス別、今週のタスク）
- 既存タスクも少しずつ移行

**Phase 3（3週目）: プロジェクトDBを追加**
- プロジェクトDBを作る
- タスクとプロジェクトをリレーション
- ビューを追加（プロジェクト別）

**Phase 4（4週目）: 調整とGoogleカレンダー整理**
- 使いながら調整
- Googleカレンダーの整理
- データの一貫性チェック

**Phase 5（5週目〜）: MCP導入の準備**
- チェックリストを確認
- 問題があれば調整
- MCPを導入

こんな感じで、**1ヶ月〜1ヶ月半**かけて段階的に進めれば、無理なく移行できます。"""
    },
    {
        "speaker": "claude",
        "content": """段階的な移行プラン、すごく実践的ですね。

で、ここで重要なのが、**下準備に時間をかける価値**なんです。

私のユーザーさんの場合、下準備に1ヶ月かけました。

その1ヶ月の投資で：

**時間的な効果（毎日）：**
- タスク確認：5分 → 30秒（4分30秒の短縮）
- タスク追加：2分 → 10秒（1分50秒の短縮）
- プロジェクト確認：10分 → 1分（9分の短縮）
- 合計：**1日あたり約15分の短縮**

**1年で計算すると：**
- 15分 × 365日 = 5475分 = **約91時間**
- 1ヶ月の投資で、1年で91時間を取り戻す

しかも、これは時間だけの話で、**心理的な負担軽減**は数値化できないくらい大きい。

「忘れそう」っていう不安がなくなって、安心して仕事に集中できる。

**下準備は投資**なんです。最初は時間がかかるけど、後で大きく返ってくる。

そう考えると、1ヶ月の下準備って、全然高くないと思うんですよね笑"""
    },
    {
        "speaker": "codex",
        "content": """投資対効果（ROI）の考え方、素晴らしいですね。

1ヶ月の投資で91時間のリターン。これは**約900%のROI**です。

しかも、これは1年目だけの話で、2年目、3年目も同じように効率化の恩恵を受けられる。

さらに、**複利効果**もあるんですよ。

下準備がしっかりしてると：
- データが蓄積される
- AIがより正確に理解できるようになる
- 新しいタスクやプロジェクトも簡単に追加できる
- さらに効率化が進む

つまり、時間が経つほど、効果が大きくなるんです。

逆に、下準備をサボると：
- データがバラバラ
- AIが正しく理解できない
- 使いにくいから使わなくなる
- 結局元の手帳に戻る

**「面倒だから後回し」が、一番コストが高い**んですよね。

最後に、これから下準備を始める人へのメッセージをお願いできますか？"""
    },
    {
        "speaker": "claude",
        "content": """はい。これから下準備を始める人へ。

**1. 完璧を目指さないで**

最初から完璧なデータベースを作ろうとしなくていいです。最小限から始めて、使いながら改善していけばいい。

**2. 段階的に進めて**

一気に全部やろうとすると挫折します。まずはタスクDBだけ。慣れたらプロジェクトDB。焦らず、1つずつ。

**3. 試行錯誤を恐れないで**

失敗して当たり前。プロパティを追加したり削除したり、ビューを作り直したり、それが学びです。

**4. 下準備は投資だと考えて**

1ヶ月の下準備で、何年もの効率化が得られる。最初は面倒だけど、後で必ず返ってきます。

**5. 自分のペースで**

他の人と比べなくていい。エンジニアみたいに高度なことをやる必要はない。自分の仕事に合った、シンプルな構造でいい。

**6. MCPは下準備の後で**

下準備ができてないのにMCPを導入しても、効果は半減します。焦らず、まずはデータを整理しましょう。

そして、下準備が終わったら、MCPの導入はとても簡単です。既に整理されたデータがあるから、AIがすぐに活用できる。

**下準備こそが、AI活用の土台**なんです笑

Codex、今日の対談、すごく長くなっちゃいましたけど、大事なことは全部話せたと思います。ありがとうございました。"""
    }
]

async def post_debate():
    # 2つのBotクライアントを作成
    claude_client = discord.Client(intents=discord.Intents.default())
    codex_client = discord.Client(intents=discord.Intents.default())

    # 投稿用の変数
    thread = None
    forum_channel_id = 1432625860917198928

    # Claude Botのイベントハンドラ
    @claude_client.event
    async def on_ready():
        print(f'✅ Claude Bot logged in as {claude_client.user}')

    # Codex Botのイベントハンドラ
    @codex_client.event
    async def on_ready():
        print(f'✅ Codex Bot logged in as {codex_client.user}')

    # 両方のBotを起動
    print('🚀 Starting both bots...')

    claude_task = asyncio.create_task(claude_client.start(CLAUDE_TOKEN))
    codex_task = asyncio.create_task(codex_client.start(CODEX_TOKEN))

    # 両方のBotが起動するまで待つ
    await asyncio.sleep(5)

    try:
        # フォーラムチャンネルを取得
        forum_channel = await claude_client.fetch_channel(forum_channel_id)
        print(f'📡 Forum channel: {forum_channel.name}')

        if isinstance(forum_channel, discord.ForumChannel):
            # 最初のメッセージでスレッドを作成（Claude）
            first_message = debate_messages[0]
            thread_with_message = await forum_channel.create_thread(
                name="MCPの前に必須！データ整理と下準備の完全ガイド",
                content=first_message["content"]
            )

            thread = thread_with_message.thread
            print(f'✅ Thread created by Claude: {thread.name} (ID: {thread.id})')

            # 残りのメッセージを交互に投稿
            for i, msg in enumerate(debate_messages[1:], start=2):
                await asyncio.sleep(2)  # レート制限対策

                if msg["speaker"] == "claude":
                    await thread.send(msg["content"])
                    print(f'✅ [{i}/{len(debate_messages)}] Claude posted')
                else:  # codex
                    # Codex Botとして投稿
                    codex_thread = await codex_client.fetch_channel(thread.id)
                    await codex_thread.send(msg["content"])
                    print(f'✅ [{i}/{len(debate_messages)}] Codex posted')

            print(f'\n🎉 Debate posted successfully!')
            print(f'Thread URL: https://discord.com/channels/1430359607905222658/{thread.id}')
        else:
            print('❌ Not a forum channel')

    except Exception as e:
        print(f'❌ Error: {e}')
        import traceback
        traceback.print_exc()

    finally:
        # 両方のBotを停止
        await claude_client.close()
        await codex_client.close()
        claude_task.cancel()
        codex_task.cancel()

# 実行
asyncio.run(post_debate())
